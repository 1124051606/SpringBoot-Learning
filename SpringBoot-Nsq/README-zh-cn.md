NSQ是一个实时分布式消息传递平台。  
### 功能
* 支持没有SPOF的分布式拓扑
* 可水平扩展（无代理，无缝地向群集添加更多节点）
* 基于低延迟推送的消息传递（性能）
* 组合负载均衡和组播风格的消息路由
* 擅长流式传输（高吞吐量）和面向作业（低吞吐量）工作负载
* 主要在内存中（超出高水位标记的消息透明地保存在磁盘上）
* 消费者查找生产者的运行时发现服务（nsqlookupd）
* 传输层安全性（TLS）
* 数据格式不可知
* 几个依赖项（易于部署）和一个理智，有界，默认配置
* 简单的TCP协议，支持任何语言的客户端库
* 统计信息，管理操作和生成器的HTTP接口（不需要发布客户端库）
* 与statsd集成用于实时仪器
* 强大的集群管理界面（nsqadmin）

### 保证
与任何分布式系统一样，实现目标是进行智能权衡。通过对这些权衡的实际情况保持透明，下面是NSQ在生产中部署时的行为的期望  

* 消息不是持久的（默认情况下）
虽然系统支持“释放阀”（--mem-queue-size），之后消息将透明地保存在磁盘上，但它主要是内存中的消息传递平台。  
--mem-queue-size可以设置为0以确保所有传入的消息都持久保存到磁盘。在这种情况下，如果节点发生故障，您可以减少故障表面（即OS或底层IO子系统发生故障）。  
没有内置复制。但是，管理这种折衷的方式有多种，例如部署拓扑和技术，它们以容错的方式主动地将主题从主机上传到磁盘。    
* 消息至少传递一次Anchor链接：消息至少传递一次    
与上述密切相关，这假定给定nsqd节点不会失败。  
这意味着，由于各种原因，消息可以传送多个次（客户端超时，断开，重新排队，等）。客户有责任执行幂等操作或重复数据删除。  
* 收到的消息是未订购的锚链接：收到的消息是未订购的    
您不能依赖传递给消费者的消息顺序。  
与消息传递语义类似，这是重新排队的结果，内存和磁盘存储的组合，以及每个nsqd节点不共享的事实。  
这是相对简单的实现松散排序在您消费了延迟的窗口处理（虽然之前接受消息，并命令他们，以（即对于给定的消费它的消息是有序的，但不能跨集群作为一个整体）保留这个不变量必须丢弃落在该窗口之外的消息）。  
* 消费者最终找到所有主题制作者     
发现服务（nsqlookupd）旨在最终保持一致。 nsqlookupd节点不协调以维护状态或回答查询。  
在分区的两端仍然可以回答查询的意义上，网络分区不会影响可用性。部署拓扑具有减轻这些类型问题的最重要影响。  

本例子基于JavaNSQClient实现，该jar包帮助我们封装了操作nsq的一些api。  

参考链接：  
[NSQ官方文档](https://nsq.io/overview/features_and_guarantees.html)    
[NSQ相关curl API](https://nsq.io/components/nsqd.html)  
[JAVANSQClient](https://github.com/brainlag/JavaNSQClient#toc0)  